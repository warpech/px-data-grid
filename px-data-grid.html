<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../vaadin-grid/vaadin-grid.html">
<link rel="import" href="../vaadin-grid/vaadin-grid-selection-column.html">
<link rel="import" href="../vaadin-grid/vaadin-grid-sorter.html">
<link rel="import" href="../px-spinner/px-spinner.html">
<link rel="import" href="px-data-grid-column.html">
<link rel="import" href="px-auto-filter-field.html">
<link rel="import" href="px-data-grid-theme.html">
<link rel="import" href="../app-localize-behavior/app-localize-behavior.html"/>

<dom-module id="px-data-grid">
  <template>
    <style>
      :host {
        position: relative;
        display: block;
      }

      .cell-content-wrapper {
        margin-top: calc(0px - var(--px-data-grid-padding-top));
        margin-bottom: calc(0px - var(--px-data-grid-padding-top));
        margin-left: calc(0px - var(--px-data-grid-padding-top));
        margin-right: calc(0px - var(--px-data-grid-padding-top));
        padding-top: var(--px-data-grid-padding-top);
        padding-bottom: var(--px-data-grid-padding-bottom);
        padding-left: var(--px-data-grid-padding-left);
        padding-right: var(--px-data-grid-padding-right);
      }

      .action-bar {
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        justify-content: space-between;
      }

      .action-bar > * {
        flex-grow: 1;
      }

      px-spinner {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }

      px-spinner[hidden] {
        display: none;
      }
    </style>

    <template is="dom-if" if="{{_showActionBar(autoFilter, actionMenu)}}">

      <div class="action-bar">
        <template is="dom-if" if="[[autoFilter]]">
          <px-auto-filter-field
            placeholder="[[localize('Filter')]]"
            on-filter-change="_autoFilterChanged"
          >
          </px-auto-filter-field>
        </template>

        <template is="dom-if" if="[[actionMenu]]">
          <px-dropdown multi hide-selected
            display-value="[[localize('Table Actions')]]"
            items="[[_actionMenuContent]]"
            disable-clear
            on-px-dropdown-click="_actionClicked">
          </px-dropdown>
        </template>

      </div>
    </template>

    <vaadin-grid items="[[tableData]]"
                 size="[[size]]"
                 data-provider="[[remoteDataProvider]]"
                 active-item="[[activeItem]]"
                 column-reordering-allowed="[[columnReorderingAllowed]]"
                 expanded-items="[[expandedItems]]"
                 striped$="[[striped]]"
                 selected-items="{{selectedItems}}"
                 multi-sort="[[multiSort]]"
                 loading="{{_loading}}">

      <template is="dom-if" if="[[selectable]]" restamp>
        <vaadin-grid-selection-column auto-select hidden="[[hideSelectionColumn]]">
        </vaadin-grid-selection-column>
      </template>

      <!-- Automatically generated columns -->
      <template is="dom-repeat" items="[[_generatedColumns]]" as="column">
        <px-data-grid-column resizable="[[resizable]]" name="[[column.name]]" hidden="[[column.hidden]]" language="[[language]]" resources="[[resources]]">
          <template class="header">
            <vaadin-grid-sorter path="[[column.name]]">[[column.name]]</vaadin-grid-sorter>
          </template>
          <template>
            <div class="cell-content-wrapper" style$="[[_getCellStyle(item, column)]]" on-mouseover="_fireCellHoverEvent" on-mouseout="_fireCellUnhoverEvent">[[get(column.name, item)]]</div>
          </template>
        </px-data-grid-column>
      </template>

      <!-- The slot for manually provided columns -->
      <slot></slot>

    </vaadin-grid>
    <px-spinner size="40" hidden$="[[_spinnerHidden]]"></px-spinner>
  </template>
  <script>
    {
      class DataGridElement extends Polymer.mixinBehaviors([Polymer.AppLocalizeBehavior], Polymer.Element) {

        static get is() {
          return 'px-data-grid';
        }

        static get properties() {
          return {

            /**
             * Data for the table to display.
             *
             * Expected data format is a JSON array of objects. Each object in the array represents a row in the table.
             *
             * Each item in an object will be displayed as a separate column, unless px-data-table-columns are
             * defined to limit which columns are displayed.
             */
            tableData: {
              type: Array,
              observer: '_tableDataChanged',
              notify: true
            },

            /**
             * Use the selectable property if one or more rows within the table should be selectable. See also `singleSelect`.
             */
            selectable: {
              type: Boolean,
              value: false
            },

            /**
             * If true, hides the column with checkboxes.
             */
            hideSelectionColumn: {
              type: Boolean,
              value: false
            },

            /**
             * An array that contains the selected items.
             */
            selectedItems: {
              type: Array,
              value: () => [],
              notify: true
            },

            /**
             * The total number of items
             */
            size: {
              type: Number,
              value: undefined
            },

            /**
             * Number of items fetched at a time from the dataprovider.
             */
            pageSize: {
              type: Number,
              value: undefined
            },

            /**
             * When `true`, user can sort by multiple columns
             */
            multiSort: {
              type: Boolean,
              value: false
            },

            /**
             * The item user has last interacted with. Turns to `null` after user deactivates
             * the item by re-interacting with the currently active item.
             */
            activeItem: {
              type: Object,
              notify: true,
              value: null
            },

            /**
             * When `true`, user can resize columns
             */
            resizable: {
              type: Boolean,
              value: false
            },

            /**
             * Set to true to allow column reordering.
             */
            columnReorderingAllowed: {
              type: Boolean,
              value: false
            },

            /**
            * An array containing references to expanded items.
            */
            expandedItems: {
              type: Array,
              value: []
            },

            /**
             * Define if table action menu is shown or not
             */
            actionMenu: {
              type: Boolean,
              value: false
            },

            /**
             * In case px-data-table-columns aren't provided, table columns will be generated automatically.
             * They will be stamped via
             *
             * <template is="dom-repeat" items="[[_generatedColumns]]">
             *   ...
             * </template>
             *
             * @private
             */
            _generatedColumns: {
              type: Array
            },

            /**
            * Content of action menu
            */
            _actionMenuContent: {
              type: Array
            },

            /**
             * A valid IETF language tag as a string that `app-localize-behavior` will
             * use to localize this component.
             *
             * See https://github.com/PolymerElements/app-localize-behavior for API
             * documentation and more information.
             */
            language: {
              type: String,
              value: 'en'
            },

            /**
             * Use the key for localization if value for that language is missing.
             * Should always be true for Predix components.
             */
            useKeyIfMissing: {
              type: Boolean,
              value: true
            },

            /**
             * Library object of hardcoded strings used in this application.
             * Used by `app-localize-behavior` in conjunction with `language`.
             */
            resources: {
              type: Object,
              value: function() {
                // can also load these from external file as shown here:
                // https://www.polymer-project.org/2.0/toolbox/localize
                return {
                  'en': {
                    'Table Actions': 'Table Actions',
                    'Freeze column': 'Freeze column',
                    'Unfreeze column': 'Unfreeze column',
                    'Hide column': 'Hide column'
                  },
                  'fr': {
                    'Table Actions': 'Actions de la table'
                  },
                  'fi': {
                    'Table Actions': 'Taulukkotoiminnot',
                    'Hide column': 'Piilota sarake'
                  }
                };
              }
            },

            /**
             * All custom table actions. Should return array of objects with 'name' (String) and 'action' (function).
             */
            tableActions: {
              type: Array,
              value: []
            },

            /**
             * Function that provides items lazily. Receives arguments params, callback
             */
            remoteDataProvider: {
              type: Function
            },

            /**
             * If true, every other row in the table will appear with a background color to improve visual scanning.
             */
            striped: {
              type: Boolean,
              value: false
            },

            /**
             * Shows if there is any pending request for remote data.
             */
            _loading: {
              type: Boolean,
              value: false,
              observer: '_loadingChanged'
            },

            _spinnerHidden: {
              type: Boolean,
              value: true
            },

            /**
             * How many milliseconds before loading spinner will be shown
             */
            loadingSpinnerDebounce: {
              type: Number,
              value: 500
            },

            /**
             * To enable automatic filtering change property to true
             */
            autoFilter: {
              type: Boolean,
              value: false
            },

            /**
             * Array of objects of conditions used to highlight specific columns.
             * Format:
             * ```javascript
             * {
             *   type: 'cell',
             *   condition: (cellContent, column, item) => { return cellContent == 'John Doe' },
             * },
             * {
             *   type: 'row',
             *   condition: (cellContent, item) => { return cellContent[0] == 'a' },
             *   color: '#a8a8a8'
             * },
             * {
             *   type: 'column',
             *   condition (column, item) => { return column.name == 'age' },
             *   color: 'pink'
             * }
             * ```
             */
            highlight: {
              type: Array,
              value: []
            }
          };
        }

        ready() {
          super.ready();
          this._vaadinGrid = this.shadowRoot.querySelector('vaadin-grid');
          this._vaadinGrid._filter = this._filter;

          this.addEventListener('column-froze', (event) => {
            this._vaadinGrid.insertBefore(event.detail.column, this._vaadinGrid.firstElementChild);
            this._vaadinGrid._observer.flush();
          });

          this.addEventListener('column-unfroze', (event) => {
            const columnsRow = this._vaadinGrid._columnTree[this._vaadinGrid._columnTree.length - 1].slice(0);
            const lastFrozen = columnsRow.filter((column) => column._lastFrozen)[0];
            if (lastFrozen) {
              this._vaadinGrid.insertBefore(event.detail.column, lastFrozen.nextSibling);
            }
          });

          this._addColumnsObserver();

          if (this.highlight.length) {
            this._vaadinGrid.setAttribute('highlighted', '');
            this.setAttribute('highlighted', '');
          }
        }

        _fireCellHoverEvent(event) {
          this.dispatchEvent(
            new CustomEvent('cell-hover', {
              bubbles: true,
              composed: true,
              detail: {
                item: event.model.item,
                column: event.model.column,
                cellContent: this.get(event.model.column.name, event.model.item)
              }
            })
          );
        }

        _fireCellUnhoverEvent(event) {
          this.dispatchEvent(
            new CustomEvent('cell-unhover', {
              bubbles: true,
              composed: true,
              detail: {
                item: event.model.item,
                column: event.model.column,
                cellContent: this.get(event.model.column.name, event.model.item)
              }
            })
          );
        }

        _getCellStyle(item, column) {
          if (!this.highlight) {
            return;
          }

          let columnColor;
          let rowColor;
          let cellColor;

          this.highlight.forEach((highlightEntity) => {
            switch (highlightEntity.type) {
              case 'cell':
                if (highlightEntity.condition(this.get(column.name, item), column, item)) {
                  if (highlightEntity.color) {
                    cellColor = `background: ${highlightEntity.color}`;
                  } else {
                    cellColor = 'background: var(--px-data-grid-highlight--high, #DDD)';
                  }
                }
                break;
              case 'row':
                if (this._isRowConditionApplied(item, highlightEntity.condition)) {
                  if (highlightEntity.color) {
                    rowColor = `background: ${highlightEntity.color}`;
                  } else {
                    rowColor = 'background: var(--px-data-grid-highlight--high, #DDD)';
                  }
                }
                break;
              case 'column':
                if (this._isColumnConditionApplied(column, highlightEntity.condition)) {
                  if (highlightEntity.color) {
                    columnColor = `background: ${highlightEntity.color}`;
                  } else {
                    columnColor = 'background: var(--px-data-grid-highlight--high, #DDD)';
                  }
                }
                break;
            }
          });

          if (cellColor) {
            return cellColor;
          } else if (rowColor) {
            return rowColor;
          } else {
            return columnColor;
          }
        }

        _isRowConditionApplied(item, condition) {
          return !!this._generatedColumns.filter(column => {
            const cellText = this.get(column.name, item);
            return condition(cellText, item);
          }).length;
        }

        _isColumnConditionApplied(column, condition) {
          const cachedItems = this._vaadinGrid._cache.items;
          const itemsArray = Object.keys(cachedItems).map(key => cachedItems[key]);

          return !!itemsArray.filter(item => {
            return condition(column, item);
          }).length;
        }

        _tableDataChanged(tableData) {
          this._populateTableColumns(tableData);
        }

        _populateTableColumns(data) {
          const manualColumns = this.querySelectorAll(Predix.DataGridColumnElement.is);

          if (!manualColumns.length && data && data.length) {
            this._generatedColumns = [];
            for (const key in data[0]) {
              this._generatedColumns.push({
                'name': key,
                'hidden': false
              });
            }

            this._updateActionMenu();
          }

        }

        /**
         * Event handler for action menu clicks
         */
        _actionClicked(evt) {
          const item = evt.detail.detail.item;
          const key = item.key;

          if (key.action) {
            key.action();
          }
        }

        /**
         * Function to resolve columns on grid
         */
        _getColumns() {
          if (this._vaadinGrid._columnTree) {
            return this._vaadinGrid._columnTree[0];
          } else if (this._generatedColumns && this._generatedColumns.length) {
            return this._generatedColumns;
          } else {
            return [];
          }

        }

        /**
         * Function called when action menu content needs to be updated
         */
        _updateActionMenu() {
          const content = [];

          // Application specific options

          if (this.tableActions) {
            this.tableActions.forEach(function(item) {
              content.push({
                key: {
                  action: item.action
                },
                val: item.name,
                selected: false,
                disabled: true
              });
            });
          }

          // Add column hide/show selection

          const defaultName = this.localize('Column #');
          let counter = 0;

          this._getColumns().forEach(function(columnElement) {
            const index = ++counter;
            const hidden = columnElement.hidden ? columnElement.hidden : false;
            const name = columnElement.name ? columnElement.name : (defaultName + index);

            content.push({
              key: {
                action: function() {
                  columnElement.hidden = !(columnElement.hidden ? columnElement.hidden : false);
                }
              },
              val: name,
              selected: !hidden
            });
          });

          this._actionMenuContent = content;
        }

        /**
         * Observer for internal DOM changes
         */
        _addColumnsObserver() {
          this._observer = new Polymer.FlattenedNodesObserver(this, info => {
            const manualColumns = this.querySelectorAll(Predix.DataGridColumnElement.is);
            this._handleManualColumns(manualColumns);
          });
        }

        _handleManualColumns(manualColumns) {
          manualColumns.forEach((column) => {
            column.language = this.language;
            column.resources = this.resources;
          });

          if (manualColumns.length) {
            this._generatedColumns = [];
          } else {
            this._populateTableColumns();
          }
          this._updateActionMenu();
        }

        _loadingChanged(loading) {
          clearTimeout(this._spinnerHiddenTimeout);

          if (loading) {
            this._spinnerHiddenTimeout = setTimeout(() => this._spinnerHidden = false, this.loadingSpinnerDebounce);
          } else {
            this._spinnerHidden = true;
          }
        }

        /**
         * Simple method to check if action bar should be shown
         */
        _showActionBar(filterField, actionDropDown) {
          return filterField || actionDropDown;
        }

        /**
         * Overridden version of  default _filter method of vaadin-grid
         */
        _filter(items) {
          return items.filter((item, index) => {
            return this._filters.filter(filter => {
              const filterValueLowercase = this._normalizeEmptyValue(filter.value).toString().toLowerCase();
              if (item && filter.path === undefined) {
                for (const key in item) {
                  const value = this._normalizeEmptyValue(Polymer.Base.get(key, item));
                  if (value.toString().toLowerCase().indexOf(filterValueLowercase) !== -1) {
                    return false;
                  }
                }
                return true;
              } else {
                const value = this._normalizeEmptyValue(Polymer.Base.get(filter.path, item));
                return value.toString().toLowerCase().indexOf(filterValueLowercase) === -1;
              }
            }).length === 0;
          });
        }

        /**
         * Listener for auto filter component
         */
        _autoFilterChanged(event) {
          // Ignore if autofiltering not enabled
          if (!this.autoFilter) {
            return;
          } else {
            const filters = [
              {
                value: event.detail.value
              }
            ];

            this._vaadinGrid._filters = filters;
            this._vaadinGrid.clearCache();
          }
        }
      }
      customElements.define(DataGridElement.is, DataGridElement);

      /**
       * @namespace Predix
       */
      window.Predix = window.Predix || {};
      Predix.DataGridElement = DataGridElement;
    }
  </script>
</dom-module>
